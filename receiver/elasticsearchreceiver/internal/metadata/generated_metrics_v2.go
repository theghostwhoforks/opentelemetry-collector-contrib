// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/model/pdata"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// MetricsSettings provides settings for elasticsearchreceiver metrics.
type MetricsSettings struct {
	ElasticsearchClusterDataNodes            MetricSettings `mapstructure:"elasticsearch.cluster.data_nodes"`
	ElasticsearchClusterNodes                MetricSettings `mapstructure:"elasticsearch.cluster.nodes"`
	ElasticsearchClusterShards               MetricSettings `mapstructure:"elasticsearch.cluster.shards"`
	ElasticsearchNodeCacheEvictions          MetricSettings `mapstructure:"elasticsearch.node.cache.evictions"`
	ElasticsearchNodeCacheMemoryUsage        MetricSettings `mapstructure:"elasticsearch.node.cache.memory.usage"`
	ElasticsearchNodeClusterConnections      MetricSettings `mapstructure:"elasticsearch.node.cluster.connections"`
	ElasticsearchNodeClusterIo               MetricSettings `mapstructure:"elasticsearch.node.cluster.io"`
	ElasticsearchNodeDocuments               MetricSettings `mapstructure:"elasticsearch.node.documents"`
	ElasticsearchNodeFsDiskAvailable         MetricSettings `mapstructure:"elasticsearch.node.fs.disk.available"`
	ElasticsearchNodeHTTPConnections         MetricSettings `mapstructure:"elasticsearch.node.http.connections"`
	ElasticsearchNodeJvmGcClassesLoaded      MetricSettings `mapstructure:"elasticsearch.node.jvm.gc.classes.loaded"`
	ElasticsearchNodeJvmGcCollectionsCount   MetricSettings `mapstructure:"elasticsearch.node.jvm.gc.collections.count"`
	ElasticsearchNodeJvmGcCollectionsTime    MetricSettings `mapstructure:"elasticsearch.node.jvm.gc.collections.time"`
	ElasticsearchNodeJvmMemoryCommitted      MetricSettings `mapstructure:"elasticsearch.node.jvm.memory.committed"`
	ElasticsearchNodeJvmMemoryInit           MetricSettings `mapstructure:"elasticsearch.node.jvm.memory.init"`
	ElasticsearchNodeJvmMemoryLimit          MetricSettings `mapstructure:"elasticsearch.node.jvm.memory.limit"`
	ElasticsearchNodeJvmMemoryPoolCommit     MetricSettings `mapstructure:"elasticsearch.node.jvm.memory.pool.commit"`
	ElasticsearchNodeJvmMemoryPoolInit       MetricSettings `mapstructure:"elasticsearch.node.jvm.memory.pool.init"`
	ElasticsearchNodeJvmMemoryPoolLimit      MetricSettings `mapstructure:"elasticsearch.node.jvm.memory.pool.limit"`
	ElasticsearchNodeJvmMemoryPoolUsage      MetricSettings `mapstructure:"elasticsearch.node.jvm.memory.pool.usage"`
	ElasticsearchNodeJvmMemoryUsage          MetricSettings `mapstructure:"elasticsearch.node.jvm.memory.usage"`
	ElasticsearchNodeJvmThreadsCount         MetricSettings `mapstructure:"elasticsearch.node.jvm.threads.count"`
	ElasticsearchNodeJvmThreadsPeak          MetricSettings `mapstructure:"elasticsearch.node.jvm.threads.peak"`
	ElasticsearchNodeOpenFiles               MetricSettings `mapstructure:"elasticsearch.node.open_files"`
	ElasticsearchNodeOperationsCompleted     MetricSettings `mapstructure:"elasticsearch.node.operations.completed"`
	ElasticsearchNodeOperationsTime          MetricSettings `mapstructure:"elasticsearch.node.operations.time"`
	ElasticsearchNodeShardsSize              MetricSettings `mapstructure:"elasticsearch.node.shards.size"`
	ElasticsearchNodeThreadPoolTasksFinished MetricSettings `mapstructure:"elasticsearch.node.thread_pool.tasks.finished"`
	ElasticsearchNodeThreadPoolTasksQueued   MetricSettings `mapstructure:"elasticsearch.node.thread_pool.tasks.queued"`
	ElasticsearchNodeThreadPoolThreads       MetricSettings `mapstructure:"elasticsearch.node.thread_pool.threads"`
	ElasticserachClusterHealth               MetricSettings `mapstructure:"elasticserach.cluster.health"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		ElasticsearchClusterDataNodes: MetricSettings{
			Enabled: true,
		},
		ElasticsearchClusterNodes: MetricSettings{
			Enabled: true,
		},
		ElasticsearchClusterShards: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeCacheEvictions: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeCacheMemoryUsage: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeClusterConnections: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeClusterIo: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeDocuments: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeFsDiskAvailable: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeHTTPConnections: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeJvmGcClassesLoaded: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeJvmGcCollectionsCount: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeJvmGcCollectionsTime: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeJvmMemoryCommitted: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeJvmMemoryInit: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeJvmMemoryLimit: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeJvmMemoryPoolCommit: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeJvmMemoryPoolInit: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeJvmMemoryPoolLimit: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeJvmMemoryPoolUsage: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeJvmMemoryUsage: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeJvmThreadsCount: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeJvmThreadsPeak: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeOpenFiles: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeOperationsCompleted: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeOperationsTime: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeShardsSize: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeThreadPoolTasksFinished: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeThreadPoolTasksQueued: MetricSettings{
			Enabled: true,
		},
		ElasticsearchNodeThreadPoolThreads: MetricSettings{
			Enabled: true,
		},
		ElasticserachClusterHealth: MetricSettings{
			Enabled: true,
		},
	}
}

type metricElasticsearchClusterDataNodes struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.cluster.data_nodes metric with initial data.
func (m *metricElasticsearchClusterDataNodes) init() {
	m.data.SetName("elasticsearch.cluster.data_nodes")
	m.data.SetDescription("The number of data nodes in the cluster.")
	m.data.SetUnit("{nodes}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricElasticsearchClusterDataNodes) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchClusterDataNodes) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchClusterDataNodes) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchClusterDataNodes(settings MetricSettings) metricElasticsearchClusterDataNodes {
	m := metricElasticsearchClusterDataNodes{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchClusterNodes struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.cluster.nodes metric with initial data.
func (m *metricElasticsearchClusterNodes) init() {
	m.data.SetName("elasticsearch.cluster.nodes")
	m.data.SetDescription("The total number of nodes in the cluster.")
	m.data.SetUnit("{nodes}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricElasticsearchClusterNodes) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchClusterNodes) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchClusterNodes) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchClusterNodes(settings MetricSettings) metricElasticsearchClusterNodes {
	m := metricElasticsearchClusterNodes{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchClusterShards struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.cluster.shards metric with initial data.
func (m *metricElasticsearchClusterShards) init() {
	m.data.SetName("elasticsearch.cluster.shards")
	m.data.SetDescription("The number of shards in the cluster.")
	m.data.SetUnit("{shards}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchClusterShards) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, shardStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.ShardState, pdata.NewAttributeValueString(shardStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchClusterShards) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchClusterShards) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchClusterShards(settings MetricSettings) metricElasticsearchClusterShards {
	m := metricElasticsearchClusterShards{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeCacheEvictions struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.cache.evictions metric with initial data.
func (m *metricElasticsearchNodeCacheEvictions) init() {
	m.data.SetName("elasticsearch.node.cache.evictions")
	m.data.SetDescription("The number of evictions from the cache.")
	m.data.SetUnit("{evictions}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeCacheEvictions) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, cacheNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.CacheName, pdata.NewAttributeValueString(cacheNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeCacheEvictions) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeCacheEvictions) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeCacheEvictions(settings MetricSettings) metricElasticsearchNodeCacheEvictions {
	m := metricElasticsearchNodeCacheEvictions{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeCacheMemoryUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.cache.memory.usage metric with initial data.
func (m *metricElasticsearchNodeCacheMemoryUsage) init() {
	m.data.SetName("elasticsearch.node.cache.memory.usage")
	m.data.SetDescription("The size in bytes of the cache.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeCacheMemoryUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, cacheNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.CacheName, pdata.NewAttributeValueString(cacheNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeCacheMemoryUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeCacheMemoryUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeCacheMemoryUsage(settings MetricSettings) metricElasticsearchNodeCacheMemoryUsage {
	m := metricElasticsearchNodeCacheMemoryUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeClusterConnections struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.cluster.connections metric with initial data.
func (m *metricElasticsearchNodeClusterConnections) init() {
	m.data.SetName("elasticsearch.node.cluster.connections")
	m.data.SetDescription("The number of open tcp connections for internal cluster communication.")
	m.data.SetUnit("{connections}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeClusterConnections) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeClusterConnections) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeClusterConnections) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeClusterConnections(settings MetricSettings) metricElasticsearchNodeClusterConnections {
	m := metricElasticsearchNodeClusterConnections{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeClusterIo struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.cluster.io metric with initial data.
func (m *metricElasticsearchNodeClusterIo) init() {
	m.data.SetName("elasticsearch.node.cluster.io")
	m.data.SetDescription("The number of bytes sent and received on the network for internal cluster communication.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeClusterIo) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, directionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Direction, pdata.NewAttributeValueString(directionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeClusterIo) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeClusterIo) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeClusterIo(settings MetricSettings) metricElasticsearchNodeClusterIo {
	m := metricElasticsearchNodeClusterIo{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeDocuments struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.documents metric with initial data.
func (m *metricElasticsearchNodeDocuments) init() {
	m.data.SetName("elasticsearch.node.documents")
	m.data.SetDescription("The number of documents on the node.")
	m.data.SetUnit("{documents}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeDocuments) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, documentStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.DocumentState, pdata.NewAttributeValueString(documentStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeDocuments) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeDocuments) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeDocuments(settings MetricSettings) metricElasticsearchNodeDocuments {
	m := metricElasticsearchNodeDocuments{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeFsDiskAvailable struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.fs.disk.available metric with initial data.
func (m *metricElasticsearchNodeFsDiskAvailable) init() {
	m.data.SetName("elasticsearch.node.fs.disk.available")
	m.data.SetDescription("The amount of disk space available across all file stores for this node.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeFsDiskAvailable) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeFsDiskAvailable) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeFsDiskAvailable) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeFsDiskAvailable(settings MetricSettings) metricElasticsearchNodeFsDiskAvailable {
	m := metricElasticsearchNodeFsDiskAvailable{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeHTTPConnections struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.http.connections metric with initial data.
func (m *metricElasticsearchNodeHTTPConnections) init() {
	m.data.SetName("elasticsearch.node.http.connections")
	m.data.SetDescription("The number of HTTP connections to the node.")
	m.data.SetUnit("{connections}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeHTTPConnections) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeHTTPConnections) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeHTTPConnections) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeHTTPConnections(settings MetricSettings) metricElasticsearchNodeHTTPConnections {
	m := metricElasticsearchNodeHTTPConnections{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeJvmGcClassesLoaded struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.jvm.gc.classes.loaded metric with initial data.
func (m *metricElasticsearchNodeJvmGcClassesLoaded) init() {
	m.data.SetName("elasticsearch.node.jvm.gc.classes.loaded")
	m.data.SetDescription("The number of loaded classes.")
	m.data.SetUnit("{classes}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeJvmGcClassesLoaded) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeJvmGcClassesLoaded) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeJvmGcClassesLoaded) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeJvmGcClassesLoaded(settings MetricSettings) metricElasticsearchNodeJvmGcClassesLoaded {
	m := metricElasticsearchNodeJvmGcClassesLoaded{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeJvmGcCollectionsCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.jvm.gc.collections.count metric with initial data.
func (m *metricElasticsearchNodeJvmGcCollectionsCount) init() {
	m.data.SetName("elasticsearch.node.jvm.gc.collections.count")
	m.data.SetDescription("The number of garbage collections performed by the JVM.")
	m.data.SetUnit("{collections}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeJvmGcCollectionsCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, generationAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Generation, pdata.NewAttributeValueString(generationAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeJvmGcCollectionsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeJvmGcCollectionsCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeJvmGcCollectionsCount(settings MetricSettings) metricElasticsearchNodeJvmGcCollectionsCount {
	m := metricElasticsearchNodeJvmGcCollectionsCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeJvmGcCollectionsTime struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.jvm.gc.collections.time metric with initial data.
func (m *metricElasticsearchNodeJvmGcCollectionsTime) init() {
	m.data.SetName("elasticsearch.node.jvm.gc.collections.time")
	m.data.SetDescription("The total time spent by the JVM running the garbage collector.")
	m.data.SetUnit("ms")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeJvmGcCollectionsTime) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, generationAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Generation, pdata.NewAttributeValueString(generationAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeJvmGcCollectionsTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeJvmGcCollectionsTime) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeJvmGcCollectionsTime(settings MetricSettings) metricElasticsearchNodeJvmGcCollectionsTime {
	m := metricElasticsearchNodeJvmGcCollectionsTime{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeJvmMemoryCommitted struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.jvm.memory.committed metric with initial data.
func (m *metricElasticsearchNodeJvmMemoryCommitted) init() {
	m.data.SetName("elasticsearch.node.jvm.memory.committed")
	m.data.SetDescription("The amount of committed memory.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeJvmMemoryCommitted) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, segmentAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Segment, pdata.NewAttributeValueString(segmentAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeJvmMemoryCommitted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeJvmMemoryCommitted) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeJvmMemoryCommitted(settings MetricSettings) metricElasticsearchNodeJvmMemoryCommitted {
	m := metricElasticsearchNodeJvmMemoryCommitted{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeJvmMemoryInit struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.jvm.memory.init metric with initial data.
func (m *metricElasticsearchNodeJvmMemoryInit) init() {
	m.data.SetName("elasticsearch.node.jvm.memory.init")
	m.data.SetDescription("The initial size of memory.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeJvmMemoryInit) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, segmentAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Segment, pdata.NewAttributeValueString(segmentAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeJvmMemoryInit) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeJvmMemoryInit) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeJvmMemoryInit(settings MetricSettings) metricElasticsearchNodeJvmMemoryInit {
	m := metricElasticsearchNodeJvmMemoryInit{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeJvmMemoryLimit struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.jvm.memory.limit metric with initial data.
func (m *metricElasticsearchNodeJvmMemoryLimit) init() {
	m.data.SetName("elasticsearch.node.jvm.memory.limit")
	m.data.SetDescription("The maximum memory used by the JVM.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeJvmMemoryLimit) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, segmentAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Segment, pdata.NewAttributeValueString(segmentAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeJvmMemoryLimit) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeJvmMemoryLimit) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeJvmMemoryLimit(settings MetricSettings) metricElasticsearchNodeJvmMemoryLimit {
	m := metricElasticsearchNodeJvmMemoryLimit{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeJvmMemoryPoolCommit struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.jvm.memory.pool.commit metric with initial data.
func (m *metricElasticsearchNodeJvmMemoryPoolCommit) init() {
	m.data.SetName("elasticsearch.node.jvm.memory.pool.commit")
	m.data.SetDescription("The memory committed by the memory pool.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeJvmMemoryPoolCommit) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, memoryPoolNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.MemoryPoolName, pdata.NewAttributeValueString(memoryPoolNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeJvmMemoryPoolCommit) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeJvmMemoryPoolCommit) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeJvmMemoryPoolCommit(settings MetricSettings) metricElasticsearchNodeJvmMemoryPoolCommit {
	m := metricElasticsearchNodeJvmMemoryPoolCommit{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeJvmMemoryPoolInit struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.jvm.memory.pool.init metric with initial data.
func (m *metricElasticsearchNodeJvmMemoryPoolInit) init() {
	m.data.SetName("elasticsearch.node.jvm.memory.pool.init")
	m.data.SetDescription("The initial size of the memory pool.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeJvmMemoryPoolInit) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, memoryPoolNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.MemoryPoolName, pdata.NewAttributeValueString(memoryPoolNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeJvmMemoryPoolInit) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeJvmMemoryPoolInit) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeJvmMemoryPoolInit(settings MetricSettings) metricElasticsearchNodeJvmMemoryPoolInit {
	m := metricElasticsearchNodeJvmMemoryPoolInit{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeJvmMemoryPoolLimit struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.jvm.memory.pool.limit metric with initial data.
func (m *metricElasticsearchNodeJvmMemoryPoolLimit) init() {
	m.data.SetName("elasticsearch.node.jvm.memory.pool.limit")
	m.data.SetDescription("The max memory in use by the memory pool.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeJvmMemoryPoolLimit) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, memoryPoolNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.MemoryPoolName, pdata.NewAttributeValueString(memoryPoolNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeJvmMemoryPoolLimit) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeJvmMemoryPoolLimit) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeJvmMemoryPoolLimit(settings MetricSettings) metricElasticsearchNodeJvmMemoryPoolLimit {
	m := metricElasticsearchNodeJvmMemoryPoolLimit{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeJvmMemoryPoolUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.jvm.memory.pool.usage metric with initial data.
func (m *metricElasticsearchNodeJvmMemoryPoolUsage) init() {
	m.data.SetName("elasticsearch.node.jvm.memory.pool.usage")
	m.data.SetDescription("The memory in use by the memory pool.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeJvmMemoryPoolUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, memoryPoolNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.MemoryPoolName, pdata.NewAttributeValueString(memoryPoolNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeJvmMemoryPoolUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeJvmMemoryPoolUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeJvmMemoryPoolUsage(settings MetricSettings) metricElasticsearchNodeJvmMemoryPoolUsage {
	m := metricElasticsearchNodeJvmMemoryPoolUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeJvmMemoryUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.jvm.memory.usage metric with initial data.
func (m *metricElasticsearchNodeJvmMemoryUsage) init() {
	m.data.SetName("elasticsearch.node.jvm.memory.usage")
	m.data.SetDescription("The memory in use by the JVM.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeJvmMemoryUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, segmentAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Segment, pdata.NewAttributeValueString(segmentAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeJvmMemoryUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeJvmMemoryUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeJvmMemoryUsage(settings MetricSettings) metricElasticsearchNodeJvmMemoryUsage {
	m := metricElasticsearchNodeJvmMemoryUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeJvmThreadsCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.jvm.threads.count metric with initial data.
func (m *metricElasticsearchNodeJvmThreadsCount) init() {
	m.data.SetName("elasticsearch.node.jvm.threads.count")
	m.data.SetDescription("The number of running threads in the node's JVM process.")
	m.data.SetUnit("{threads}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeJvmThreadsCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeJvmThreadsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeJvmThreadsCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeJvmThreadsCount(settings MetricSettings) metricElasticsearchNodeJvmThreadsCount {
	m := metricElasticsearchNodeJvmThreadsCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeJvmThreadsPeak struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.jvm.threads.peak metric with initial data.
func (m *metricElasticsearchNodeJvmThreadsPeak) init() {
	m.data.SetName("elasticsearch.node.jvm.threads.peak")
	m.data.SetDescription("The highest number of concurrently running threads in the current lifetime of the node's JVM process.")
	m.data.SetUnit("{threads}")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricElasticsearchNodeJvmThreadsPeak) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeJvmThreadsPeak) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeJvmThreadsPeak) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeJvmThreadsPeak(settings MetricSettings) metricElasticsearchNodeJvmThreadsPeak {
	m := metricElasticsearchNodeJvmThreadsPeak{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeOpenFiles struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.open_files metric with initial data.
func (m *metricElasticsearchNodeOpenFiles) init() {
	m.data.SetName("elasticsearch.node.open_files")
	m.data.SetDescription("The number of open file descriptors held by the node.")
	m.data.SetUnit("{files}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeOpenFiles) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeOpenFiles) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeOpenFiles) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeOpenFiles(settings MetricSettings) metricElasticsearchNodeOpenFiles {
	m := metricElasticsearchNodeOpenFiles{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeOperationsCompleted struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.operations.completed metric with initial data.
func (m *metricElasticsearchNodeOperationsCompleted) init() {
	m.data.SetName("elasticsearch.node.operations.completed")
	m.data.SetDescription("The number of operations completed.")
	m.data.SetUnit("{operations}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeOperationsCompleted) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, operationAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Operation, pdata.NewAttributeValueString(operationAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeOperationsCompleted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeOperationsCompleted) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeOperationsCompleted(settings MetricSettings) metricElasticsearchNodeOperationsCompleted {
	m := metricElasticsearchNodeOperationsCompleted{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeOperationsTime struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.operations.time metric with initial data.
func (m *metricElasticsearchNodeOperationsTime) init() {
	m.data.SetName("elasticsearch.node.operations.time")
	m.data.SetDescription("Time spent on operations.")
	m.data.SetUnit("ms")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeOperationsTime) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, operationAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Operation, pdata.NewAttributeValueString(operationAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeOperationsTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeOperationsTime) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeOperationsTime(settings MetricSettings) metricElasticsearchNodeOperationsTime {
	m := metricElasticsearchNodeOperationsTime{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeShardsSize struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.shards.size metric with initial data.
func (m *metricElasticsearchNodeShardsSize) init() {
	m.data.SetName("elasticsearch.node.shards.size")
	m.data.SetDescription("The size of the shards assigned to this node.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeShardsSize) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeShardsSize) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeShardsSize) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeShardsSize(settings MetricSettings) metricElasticsearchNodeShardsSize {
	m := metricElasticsearchNodeShardsSize{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeThreadPoolTasksFinished struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.thread_pool.tasks.finished metric with initial data.
func (m *metricElasticsearchNodeThreadPoolTasksFinished) init() {
	m.data.SetName("elasticsearch.node.thread_pool.tasks.finished")
	m.data.SetDescription("The number of tasks finished by the thread pool.")
	m.data.SetUnit("{tasks}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeThreadPoolTasksFinished) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, threadPoolNameAttributeValue string, taskStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.ThreadPoolName, pdata.NewAttributeValueString(threadPoolNameAttributeValue))
	dp.Attributes().Insert(A.TaskState, pdata.NewAttributeValueString(taskStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeThreadPoolTasksFinished) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeThreadPoolTasksFinished) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeThreadPoolTasksFinished(settings MetricSettings) metricElasticsearchNodeThreadPoolTasksFinished {
	m := metricElasticsearchNodeThreadPoolTasksFinished{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeThreadPoolTasksQueued struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.thread_pool.tasks.queued metric with initial data.
func (m *metricElasticsearchNodeThreadPoolTasksQueued) init() {
	m.data.SetName("elasticsearch.node.thread_pool.tasks.queued")
	m.data.SetDescription("The number of queued tasks in the thread pool.")
	m.data.SetUnit("{tasks}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeThreadPoolTasksQueued) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, threadPoolNameAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.ThreadPoolName, pdata.NewAttributeValueString(threadPoolNameAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeThreadPoolTasksQueued) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeThreadPoolTasksQueued) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeThreadPoolTasksQueued(settings MetricSettings) metricElasticsearchNodeThreadPoolTasksQueued {
	m := metricElasticsearchNodeThreadPoolTasksQueued{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeThreadPoolThreads struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.thread_pool.threads metric with initial data.
func (m *metricElasticsearchNodeThreadPoolThreads) init() {
	m.data.SetName("elasticsearch.node.thread_pool.threads")
	m.data.SetDescription("The number of threads in the thread pool.")
	m.data.SetUnit("{threads}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeThreadPoolThreads) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, threadStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.ThreadState, pdata.NewAttributeValueString(threadStateAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeThreadPoolThreads) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeThreadPoolThreads) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeThreadPoolThreads(settings MetricSettings) metricElasticsearchNodeThreadPoolThreads {
	m := metricElasticsearchNodeThreadPoolThreads{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricElasticserachClusterHealth struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticserach.cluster.health metric with initial data.
func (m *metricElasticserachClusterHealth) init() {
	m.data.SetName("elasticserach.cluster.health")
	m.data.SetDescription("The health status of the cluster.")
	m.data.SetUnit("{status}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticserachClusterHealth) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, healthStatusAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.HealthStatus, pdata.NewAttributeValueString(healthStatusAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticserachClusterHealth) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticserachClusterHealth) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticserachClusterHealth(settings MetricSettings) metricElasticserachClusterHealth {
	m := metricElasticserachClusterHealth{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                                      pdata.Timestamp
	metricElasticsearchClusterDataNodes            metricElasticsearchClusterDataNodes
	metricElasticsearchClusterNodes                metricElasticsearchClusterNodes
	metricElasticsearchClusterShards               metricElasticsearchClusterShards
	metricElasticsearchNodeCacheEvictions          metricElasticsearchNodeCacheEvictions
	metricElasticsearchNodeCacheMemoryUsage        metricElasticsearchNodeCacheMemoryUsage
	metricElasticsearchNodeClusterConnections      metricElasticsearchNodeClusterConnections
	metricElasticsearchNodeClusterIo               metricElasticsearchNodeClusterIo
	metricElasticsearchNodeDocuments               metricElasticsearchNodeDocuments
	metricElasticsearchNodeFsDiskAvailable         metricElasticsearchNodeFsDiskAvailable
	metricElasticsearchNodeHTTPConnections         metricElasticsearchNodeHTTPConnections
	metricElasticsearchNodeJvmGcClassesLoaded      metricElasticsearchNodeJvmGcClassesLoaded
	metricElasticsearchNodeJvmGcCollectionsCount   metricElasticsearchNodeJvmGcCollectionsCount
	metricElasticsearchNodeJvmGcCollectionsTime    metricElasticsearchNodeJvmGcCollectionsTime
	metricElasticsearchNodeJvmMemoryCommitted      metricElasticsearchNodeJvmMemoryCommitted
	metricElasticsearchNodeJvmMemoryInit           metricElasticsearchNodeJvmMemoryInit
	metricElasticsearchNodeJvmMemoryLimit          metricElasticsearchNodeJvmMemoryLimit
	metricElasticsearchNodeJvmMemoryPoolCommit     metricElasticsearchNodeJvmMemoryPoolCommit
	metricElasticsearchNodeJvmMemoryPoolInit       metricElasticsearchNodeJvmMemoryPoolInit
	metricElasticsearchNodeJvmMemoryPoolLimit      metricElasticsearchNodeJvmMemoryPoolLimit
	metricElasticsearchNodeJvmMemoryPoolUsage      metricElasticsearchNodeJvmMemoryPoolUsage
	metricElasticsearchNodeJvmMemoryUsage          metricElasticsearchNodeJvmMemoryUsage
	metricElasticsearchNodeJvmThreadsCount         metricElasticsearchNodeJvmThreadsCount
	metricElasticsearchNodeJvmThreadsPeak          metricElasticsearchNodeJvmThreadsPeak
	metricElasticsearchNodeOpenFiles               metricElasticsearchNodeOpenFiles
	metricElasticsearchNodeOperationsCompleted     metricElasticsearchNodeOperationsCompleted
	metricElasticsearchNodeOperationsTime          metricElasticsearchNodeOperationsTime
	metricElasticsearchNodeShardsSize              metricElasticsearchNodeShardsSize
	metricElasticsearchNodeThreadPoolTasksFinished metricElasticsearchNodeThreadPoolTasksFinished
	metricElasticsearchNodeThreadPoolTasksQueued   metricElasticsearchNodeThreadPoolTasksQueued
	metricElasticsearchNodeThreadPoolThreads       metricElasticsearchNodeThreadPoolThreads
	metricElasticserachClusterHealth               metricElasticserachClusterHealth
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pdata.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(settings MetricsSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                                      pdata.NewTimestampFromTime(time.Now()),
		metricElasticsearchClusterDataNodes:            newMetricElasticsearchClusterDataNodes(settings.ElasticsearchClusterDataNodes),
		metricElasticsearchClusterNodes:                newMetricElasticsearchClusterNodes(settings.ElasticsearchClusterNodes),
		metricElasticsearchClusterShards:               newMetricElasticsearchClusterShards(settings.ElasticsearchClusterShards),
		metricElasticsearchNodeCacheEvictions:          newMetricElasticsearchNodeCacheEvictions(settings.ElasticsearchNodeCacheEvictions),
		metricElasticsearchNodeCacheMemoryUsage:        newMetricElasticsearchNodeCacheMemoryUsage(settings.ElasticsearchNodeCacheMemoryUsage),
		metricElasticsearchNodeClusterConnections:      newMetricElasticsearchNodeClusterConnections(settings.ElasticsearchNodeClusterConnections),
		metricElasticsearchNodeClusterIo:               newMetricElasticsearchNodeClusterIo(settings.ElasticsearchNodeClusterIo),
		metricElasticsearchNodeDocuments:               newMetricElasticsearchNodeDocuments(settings.ElasticsearchNodeDocuments),
		metricElasticsearchNodeFsDiskAvailable:         newMetricElasticsearchNodeFsDiskAvailable(settings.ElasticsearchNodeFsDiskAvailable),
		metricElasticsearchNodeHTTPConnections:         newMetricElasticsearchNodeHTTPConnections(settings.ElasticsearchNodeHTTPConnections),
		metricElasticsearchNodeJvmGcClassesLoaded:      newMetricElasticsearchNodeJvmGcClassesLoaded(settings.ElasticsearchNodeJvmGcClassesLoaded),
		metricElasticsearchNodeJvmGcCollectionsCount:   newMetricElasticsearchNodeJvmGcCollectionsCount(settings.ElasticsearchNodeJvmGcCollectionsCount),
		metricElasticsearchNodeJvmGcCollectionsTime:    newMetricElasticsearchNodeJvmGcCollectionsTime(settings.ElasticsearchNodeJvmGcCollectionsTime),
		metricElasticsearchNodeJvmMemoryCommitted:      newMetricElasticsearchNodeJvmMemoryCommitted(settings.ElasticsearchNodeJvmMemoryCommitted),
		metricElasticsearchNodeJvmMemoryInit:           newMetricElasticsearchNodeJvmMemoryInit(settings.ElasticsearchNodeJvmMemoryInit),
		metricElasticsearchNodeJvmMemoryLimit:          newMetricElasticsearchNodeJvmMemoryLimit(settings.ElasticsearchNodeJvmMemoryLimit),
		metricElasticsearchNodeJvmMemoryPoolCommit:     newMetricElasticsearchNodeJvmMemoryPoolCommit(settings.ElasticsearchNodeJvmMemoryPoolCommit),
		metricElasticsearchNodeJvmMemoryPoolInit:       newMetricElasticsearchNodeJvmMemoryPoolInit(settings.ElasticsearchNodeJvmMemoryPoolInit),
		metricElasticsearchNodeJvmMemoryPoolLimit:      newMetricElasticsearchNodeJvmMemoryPoolLimit(settings.ElasticsearchNodeJvmMemoryPoolLimit),
		metricElasticsearchNodeJvmMemoryPoolUsage:      newMetricElasticsearchNodeJvmMemoryPoolUsage(settings.ElasticsearchNodeJvmMemoryPoolUsage),
		metricElasticsearchNodeJvmMemoryUsage:          newMetricElasticsearchNodeJvmMemoryUsage(settings.ElasticsearchNodeJvmMemoryUsage),
		metricElasticsearchNodeJvmThreadsCount:         newMetricElasticsearchNodeJvmThreadsCount(settings.ElasticsearchNodeJvmThreadsCount),
		metricElasticsearchNodeJvmThreadsPeak:          newMetricElasticsearchNodeJvmThreadsPeak(settings.ElasticsearchNodeJvmThreadsPeak),
		metricElasticsearchNodeOpenFiles:               newMetricElasticsearchNodeOpenFiles(settings.ElasticsearchNodeOpenFiles),
		metricElasticsearchNodeOperationsCompleted:     newMetricElasticsearchNodeOperationsCompleted(settings.ElasticsearchNodeOperationsCompleted),
		metricElasticsearchNodeOperationsTime:          newMetricElasticsearchNodeOperationsTime(settings.ElasticsearchNodeOperationsTime),
		metricElasticsearchNodeShardsSize:              newMetricElasticsearchNodeShardsSize(settings.ElasticsearchNodeShardsSize),
		metricElasticsearchNodeThreadPoolTasksFinished: newMetricElasticsearchNodeThreadPoolTasksFinished(settings.ElasticsearchNodeThreadPoolTasksFinished),
		metricElasticsearchNodeThreadPoolTasksQueued:   newMetricElasticsearchNodeThreadPoolTasksQueued(settings.ElasticsearchNodeThreadPoolTasksQueued),
		metricElasticsearchNodeThreadPoolThreads:       newMetricElasticsearchNodeThreadPoolThreads(settings.ElasticsearchNodeThreadPoolThreads),
		metricElasticserachClusterHealth:               newMetricElasticserachClusterHealth(settings.ElasticserachClusterHealth),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// Emit appends generated metrics to a pdata.MetricsSlice and updates the internal state to be ready for recording
// another set of data points. This function will be doing all transformations required to produce metric representation
// defined in metadata and user settings, e.g. delta/cumulative translation.
func (mb *MetricsBuilder) Emit(metrics pdata.MetricSlice) {
	mb.metricElasticsearchClusterDataNodes.emit(metrics)
	mb.metricElasticsearchClusterNodes.emit(metrics)
	mb.metricElasticsearchClusterShards.emit(metrics)
	mb.metricElasticsearchNodeCacheEvictions.emit(metrics)
	mb.metricElasticsearchNodeCacheMemoryUsage.emit(metrics)
	mb.metricElasticsearchNodeClusterConnections.emit(metrics)
	mb.metricElasticsearchNodeClusterIo.emit(metrics)
	mb.metricElasticsearchNodeDocuments.emit(metrics)
	mb.metricElasticsearchNodeFsDiskAvailable.emit(metrics)
	mb.metricElasticsearchNodeHTTPConnections.emit(metrics)
	mb.metricElasticsearchNodeJvmGcClassesLoaded.emit(metrics)
	mb.metricElasticsearchNodeJvmGcCollectionsCount.emit(metrics)
	mb.metricElasticsearchNodeJvmGcCollectionsTime.emit(metrics)
	mb.metricElasticsearchNodeJvmMemoryCommitted.emit(metrics)
	mb.metricElasticsearchNodeJvmMemoryInit.emit(metrics)
	mb.metricElasticsearchNodeJvmMemoryLimit.emit(metrics)
	mb.metricElasticsearchNodeJvmMemoryPoolCommit.emit(metrics)
	mb.metricElasticsearchNodeJvmMemoryPoolInit.emit(metrics)
	mb.metricElasticsearchNodeJvmMemoryPoolLimit.emit(metrics)
	mb.metricElasticsearchNodeJvmMemoryPoolUsage.emit(metrics)
	mb.metricElasticsearchNodeJvmMemoryUsage.emit(metrics)
	mb.metricElasticsearchNodeJvmThreadsCount.emit(metrics)
	mb.metricElasticsearchNodeJvmThreadsPeak.emit(metrics)
	mb.metricElasticsearchNodeOpenFiles.emit(metrics)
	mb.metricElasticsearchNodeOperationsCompleted.emit(metrics)
	mb.metricElasticsearchNodeOperationsTime.emit(metrics)
	mb.metricElasticsearchNodeShardsSize.emit(metrics)
	mb.metricElasticsearchNodeThreadPoolTasksFinished.emit(metrics)
	mb.metricElasticsearchNodeThreadPoolTasksQueued.emit(metrics)
	mb.metricElasticsearchNodeThreadPoolThreads.emit(metrics)
	mb.metricElasticserachClusterHealth.emit(metrics)
}

// RecordElasticsearchClusterDataNodesDataPoint adds a data point to elasticsearch.cluster.data_nodes metric.
func (mb *MetricsBuilder) RecordElasticsearchClusterDataNodesDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricElasticsearchClusterDataNodes.recordDataPoint(mb.startTime, ts, val)
}

// RecordElasticsearchClusterNodesDataPoint adds a data point to elasticsearch.cluster.nodes metric.
func (mb *MetricsBuilder) RecordElasticsearchClusterNodesDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricElasticsearchClusterNodes.recordDataPoint(mb.startTime, ts, val)
}

// RecordElasticsearchClusterShardsDataPoint adds a data point to elasticsearch.cluster.shards metric.
func (mb *MetricsBuilder) RecordElasticsearchClusterShardsDataPoint(ts pdata.Timestamp, val int64, shardStateAttributeValue string) {
	mb.metricElasticsearchClusterShards.recordDataPoint(mb.startTime, ts, val, shardStateAttributeValue)
}

// RecordElasticsearchNodeCacheEvictionsDataPoint adds a data point to elasticsearch.node.cache.evictions metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeCacheEvictionsDataPoint(ts pdata.Timestamp, val int64, cacheNameAttributeValue string) {
	mb.metricElasticsearchNodeCacheEvictions.recordDataPoint(mb.startTime, ts, val, cacheNameAttributeValue)
}

// RecordElasticsearchNodeCacheMemoryUsageDataPoint adds a data point to elasticsearch.node.cache.memory.usage metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeCacheMemoryUsageDataPoint(ts pdata.Timestamp, val int64, cacheNameAttributeValue string) {
	mb.metricElasticsearchNodeCacheMemoryUsage.recordDataPoint(mb.startTime, ts, val, cacheNameAttributeValue)
}

// RecordElasticsearchNodeClusterConnectionsDataPoint adds a data point to elasticsearch.node.cluster.connections metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeClusterConnectionsDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricElasticsearchNodeClusterConnections.recordDataPoint(mb.startTime, ts, val)
}

// RecordElasticsearchNodeClusterIoDataPoint adds a data point to elasticsearch.node.cluster.io metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeClusterIoDataPoint(ts pdata.Timestamp, val int64, directionAttributeValue string) {
	mb.metricElasticsearchNodeClusterIo.recordDataPoint(mb.startTime, ts, val, directionAttributeValue)
}

// RecordElasticsearchNodeDocumentsDataPoint adds a data point to elasticsearch.node.documents metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeDocumentsDataPoint(ts pdata.Timestamp, val int64, documentStateAttributeValue string) {
	mb.metricElasticsearchNodeDocuments.recordDataPoint(mb.startTime, ts, val, documentStateAttributeValue)
}

// RecordElasticsearchNodeFsDiskAvailableDataPoint adds a data point to elasticsearch.node.fs.disk.available metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeFsDiskAvailableDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricElasticsearchNodeFsDiskAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordElasticsearchNodeHTTPConnectionsDataPoint adds a data point to elasticsearch.node.http.connections metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeHTTPConnectionsDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricElasticsearchNodeHTTPConnections.recordDataPoint(mb.startTime, ts, val)
}

// RecordElasticsearchNodeJvmGcClassesLoadedDataPoint adds a data point to elasticsearch.node.jvm.gc.classes.loaded metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeJvmGcClassesLoadedDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricElasticsearchNodeJvmGcClassesLoaded.recordDataPoint(mb.startTime, ts, val)
}

// RecordElasticsearchNodeJvmGcCollectionsCountDataPoint adds a data point to elasticsearch.node.jvm.gc.collections.count metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeJvmGcCollectionsCountDataPoint(ts pdata.Timestamp, val int64, generationAttributeValue string) {
	mb.metricElasticsearchNodeJvmGcCollectionsCount.recordDataPoint(mb.startTime, ts, val, generationAttributeValue)
}

// RecordElasticsearchNodeJvmGcCollectionsTimeDataPoint adds a data point to elasticsearch.node.jvm.gc.collections.time metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeJvmGcCollectionsTimeDataPoint(ts pdata.Timestamp, val int64, generationAttributeValue string) {
	mb.metricElasticsearchNodeJvmGcCollectionsTime.recordDataPoint(mb.startTime, ts, val, generationAttributeValue)
}

// RecordElasticsearchNodeJvmMemoryCommittedDataPoint adds a data point to elasticsearch.node.jvm.memory.committed metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeJvmMemoryCommittedDataPoint(ts pdata.Timestamp, val int64, segmentAttributeValue string) {
	mb.metricElasticsearchNodeJvmMemoryCommitted.recordDataPoint(mb.startTime, ts, val, segmentAttributeValue)
}

// RecordElasticsearchNodeJvmMemoryInitDataPoint adds a data point to elasticsearch.node.jvm.memory.init metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeJvmMemoryInitDataPoint(ts pdata.Timestamp, val int64, segmentAttributeValue string) {
	mb.metricElasticsearchNodeJvmMemoryInit.recordDataPoint(mb.startTime, ts, val, segmentAttributeValue)
}

// RecordElasticsearchNodeJvmMemoryLimitDataPoint adds a data point to elasticsearch.node.jvm.memory.limit metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeJvmMemoryLimitDataPoint(ts pdata.Timestamp, val int64, segmentAttributeValue string) {
	mb.metricElasticsearchNodeJvmMemoryLimit.recordDataPoint(mb.startTime, ts, val, segmentAttributeValue)
}

// RecordElasticsearchNodeJvmMemoryPoolCommitDataPoint adds a data point to elasticsearch.node.jvm.memory.pool.commit metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeJvmMemoryPoolCommitDataPoint(ts pdata.Timestamp, val int64, memoryPoolNameAttributeValue string) {
	mb.metricElasticsearchNodeJvmMemoryPoolCommit.recordDataPoint(mb.startTime, ts, val, memoryPoolNameAttributeValue)
}

// RecordElasticsearchNodeJvmMemoryPoolInitDataPoint adds a data point to elasticsearch.node.jvm.memory.pool.init metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeJvmMemoryPoolInitDataPoint(ts pdata.Timestamp, val int64, memoryPoolNameAttributeValue string) {
	mb.metricElasticsearchNodeJvmMemoryPoolInit.recordDataPoint(mb.startTime, ts, val, memoryPoolNameAttributeValue)
}

// RecordElasticsearchNodeJvmMemoryPoolLimitDataPoint adds a data point to elasticsearch.node.jvm.memory.pool.limit metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeJvmMemoryPoolLimitDataPoint(ts pdata.Timestamp, val int64, memoryPoolNameAttributeValue string) {
	mb.metricElasticsearchNodeJvmMemoryPoolLimit.recordDataPoint(mb.startTime, ts, val, memoryPoolNameAttributeValue)
}

// RecordElasticsearchNodeJvmMemoryPoolUsageDataPoint adds a data point to elasticsearch.node.jvm.memory.pool.usage metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeJvmMemoryPoolUsageDataPoint(ts pdata.Timestamp, val int64, memoryPoolNameAttributeValue string) {
	mb.metricElasticsearchNodeJvmMemoryPoolUsage.recordDataPoint(mb.startTime, ts, val, memoryPoolNameAttributeValue)
}

// RecordElasticsearchNodeJvmMemoryUsageDataPoint adds a data point to elasticsearch.node.jvm.memory.usage metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeJvmMemoryUsageDataPoint(ts pdata.Timestamp, val int64, segmentAttributeValue string) {
	mb.metricElasticsearchNodeJvmMemoryUsage.recordDataPoint(mb.startTime, ts, val, segmentAttributeValue)
}

// RecordElasticsearchNodeJvmThreadsCountDataPoint adds a data point to elasticsearch.node.jvm.threads.count metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeJvmThreadsCountDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricElasticsearchNodeJvmThreadsCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordElasticsearchNodeJvmThreadsPeakDataPoint adds a data point to elasticsearch.node.jvm.threads.peak metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeJvmThreadsPeakDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricElasticsearchNodeJvmThreadsPeak.recordDataPoint(mb.startTime, ts, val)
}

// RecordElasticsearchNodeOpenFilesDataPoint adds a data point to elasticsearch.node.open_files metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeOpenFilesDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricElasticsearchNodeOpenFiles.recordDataPoint(mb.startTime, ts, val)
}

// RecordElasticsearchNodeOperationsCompletedDataPoint adds a data point to elasticsearch.node.operations.completed metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeOperationsCompletedDataPoint(ts pdata.Timestamp, val int64, operationAttributeValue string) {
	mb.metricElasticsearchNodeOperationsCompleted.recordDataPoint(mb.startTime, ts, val, operationAttributeValue)
}

// RecordElasticsearchNodeOperationsTimeDataPoint adds a data point to elasticsearch.node.operations.time metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeOperationsTimeDataPoint(ts pdata.Timestamp, val int64, operationAttributeValue string) {
	mb.metricElasticsearchNodeOperationsTime.recordDataPoint(mb.startTime, ts, val, operationAttributeValue)
}

// RecordElasticsearchNodeShardsSizeDataPoint adds a data point to elasticsearch.node.shards.size metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeShardsSizeDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricElasticsearchNodeShardsSize.recordDataPoint(mb.startTime, ts, val)
}

// RecordElasticsearchNodeThreadPoolTasksFinishedDataPoint adds a data point to elasticsearch.node.thread_pool.tasks.finished metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeThreadPoolTasksFinishedDataPoint(ts pdata.Timestamp, val int64, threadPoolNameAttributeValue string, taskStateAttributeValue string) {
	mb.metricElasticsearchNodeThreadPoolTasksFinished.recordDataPoint(mb.startTime, ts, val, threadPoolNameAttributeValue, taskStateAttributeValue)
}

// RecordElasticsearchNodeThreadPoolTasksQueuedDataPoint adds a data point to elasticsearch.node.thread_pool.tasks.queued metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeThreadPoolTasksQueuedDataPoint(ts pdata.Timestamp, val int64, threadPoolNameAttributeValue string) {
	mb.metricElasticsearchNodeThreadPoolTasksQueued.recordDataPoint(mb.startTime, ts, val, threadPoolNameAttributeValue)
}

// RecordElasticsearchNodeThreadPoolThreadsDataPoint adds a data point to elasticsearch.node.thread_pool.threads metric.
func (mb *MetricsBuilder) RecordElasticsearchNodeThreadPoolThreadsDataPoint(ts pdata.Timestamp, val int64, threadStateAttributeValue string) {
	mb.metricElasticsearchNodeThreadPoolThreads.recordDataPoint(mb.startTime, ts, val, threadStateAttributeValue)
}

// RecordElasticserachClusterHealthDataPoint adds a data point to elasticserach.cluster.health metric.
func (mb *MetricsBuilder) RecordElasticserachClusterHealthDataPoint(ts pdata.Timestamp, val int64, healthStatusAttributeValue string) {
	mb.metricElasticserachClusterHealth.recordDataPoint(mb.startTime, ts, val, healthStatusAttributeValue)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pdata.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}

// Attributes contains the possible metric attributes that can be used.
var Attributes = struct {
	// CacheName (The name of cache.)
	CacheName string
	// Direction (The direction of network data.)
	Direction string
	// DiskUsageState (The state of a section of space on disk.)
	DiskUsageState string
	// DocumentState (The state of the document.)
	DocumentState string
	// ElasticsearchClusterName (The name of the elasticsearch cluster.)
	ElasticsearchClusterName string
	// ElasticsearchNodeName (The name of the elasticsearch node.)
	ElasticsearchNodeName string
	// FsDirection (The direction of filesystem IO.)
	FsDirection string
	// Generation (The generation on which garbage collection was performed.)
	Generation string
	// HealthStatus (The health status of the cluster.)
	HealthStatus string
	// MemoryPoolName (The name of the JVM memory pool)
	MemoryPoolName string
	// Operation (The type of operation.)
	Operation string
	// Segment (The segment of JVM memory.)
	Segment string
	// ShardState (The state of the shard.)
	ShardState string
	// TaskState (The state of the task.)
	TaskState string
	// ThreadPoolName (The name of the thread pool.)
	ThreadPoolName string
	// ThreadState (The state of the thread.)
	ThreadState string
}{
	"cache_name",
	"direction",
	"state",
	"state",
	"elasticsearch.cluster.name",
	"elasticsearch.node.name",
	"direction",
	"generation",
	"status",
	"pool",
	"operation",
	"segment",
	"state",
	"state",
	"thread_pool_name",
	"state",
}

// A is an alias for Attributes.
var A = Attributes

// AttributeCacheName are the possible values that the attribute "cache_name" can have.
var AttributeCacheName = struct {
	Fielddata string
	Query     string
}{
	"fielddata",
	"query",
}

// AttributeDirection are the possible values that the attribute "direction" can have.
var AttributeDirection = struct {
	Received string
	Sent     string
}{
	"received",
	"sent",
}

// AttributeDiskUsageState are the possible values that the attribute "disk_usage_state" can have.
var AttributeDiskUsageState = struct {
	Used string
	Free string
}{
	"used",
	"free",
}

// AttributeDocumentState are the possible values that the attribute "document_state" can have.
var AttributeDocumentState = struct {
	Active  string
	Deleted string
}{
	"active",
	"deleted",
}

// AttributeFsDirection are the possible values that the attribute "fs_direction" can have.
var AttributeFsDirection = struct {
	Read  string
	Write string
}{
	"read",
	"write",
}

// AttributeGeneration are the possible values that the attribute "generation" can have.
var AttributeGeneration = struct {
	Young string
	Old   string
}{
	"young",
	"old",
}

// AttributeHealthStatus are the possible values that the attribute "health_status" can have.
var AttributeHealthStatus = struct {
	Green  string
	Yellow string
	Red    string
}{
	"green",
	"yellow",
	"red",
}

// AttributeOperation are the possible values that the attribute "operation" can have.
var AttributeOperation = struct {
	Index   string
	Delete  string
	Get     string
	Query   string
	Fetch   string
	Scroll  string
	Suggest string
	Merge   string
	Refresh string
	Flush   string
	Warmer  string
}{
	"index",
	"delete",
	"get",
	"query",
	"fetch",
	"scroll",
	"suggest",
	"merge",
	"refresh",
	"flush",
	"warmer",
}

// AttributeSegment are the possible values that the attribute "segment" can have.
var AttributeSegment = struct {
	Heap    string
	Nonheap string
}{
	"heap",
	"nonheap",
}

// AttributeShardState are the possible values that the attribute "shard_state" can have.
var AttributeShardState = struct {
	Active       string
	Relocating   string
	Initializing string
	Unassigned   string
}{
	"active",
	"relocating",
	"initializing",
	"unassigned",
}

// AttributeTaskState are the possible values that the attribute "task_state" can have.
var AttributeTaskState = struct {
	Rejected  string
	Completed string
}{
	"rejected",
	"completed",
}

// AttributeThreadState are the possible values that the attribute "thread_state" can have.
var AttributeThreadState = struct {
	Active string
	Idle   string
}{
	"active",
	"idle",
}
